<?php
// $Id$


/**
 * @file
 * Code for Rbuild module
 *
 * Rbuild extends the OS Software feature module, providing a new field option
 * called "Rbuild repository", which OS Software provides to the field
 * field_software_method.
 *
 * OS Software responds to this field to show/hide the "Add new > Software
 * Release" contextual link, and also to show/hide a second field
 * field_software_repo on the node edit form.
 *
 * Rbuild also checks for regular updates, fetches any new packages, and creates
 * new Software Release nodes if a newer version exists.
 */

/**
 * Drupal hooks
 */

/**
 * Implements hook_form_FORM_ID_form_alter() for software_project_node_form
 */
function rbuild_form_software_project_node_form_alter(&$form, &$form_state, $form_id) {
  // Only shows the rbuild fields if "Rbuild repository" method is selected
  $form['#attached'] = array(
    'js' => array(
      'type' => 'file',
      'data' => drupal_get_path('module', 'rbuild') . '/rbuild.js',
    ),
  );

  // Checks that the provided Repository URL and Short Name are valid
  $form['#validate'][] = '_rbuild_project_node_validate';

  // Hides the Documentation text field unless user 1.
  global $user;
  $form['field_rbuild_docs']['#access'] = ((int)$user->uid === 1);
}

/**
 * Implements hook_node_insert().
 *
 * Triggers init_releases() for new rBuild Software Project nodes.
 */
function rbuild_node_insert($node) {
  if ($node->type !== 'software_project') {
    return;
  }

  // Initializes releases only for Projects whose Method field == "rBuild".
  $field_items = field_get_items('node', $node, 'field_software_method');
  $field_value = $field_items[0]['value'];
  if ($field_value !== 'Rbuild repository') {
    return;
  }

  _rbuild_node_save_modify_docs_field_value($node);
  _rbuild_init_releases($node);
}

/**
 * Implements hook_node_update()
 *
 * Triggers init_releases() if updated 'Rbuild repository' or 'rBuild Short Name'
 */
function rbuild_node_update($node) {
  if ($node->type !== 'software_project') {
    return;
  }

  // Ignores new nodes; hook_node_insert() takes care of new Software Projects
  $node_original = node_load($node->nid);
  if (!isset($node_original->title)) {
    return;
  }

  // Exits if the updated packaging method is not 'Rbuild repository'
  $field_items = field_get_items('node', $node, 'field_software_method');
  $field_value = $field_items[0]['value'];
  if ($field_value !== 'Rbuild repository') {
    return;
  }

  // Compares original and updated field values
  $node_updated        = $node;
  $field_items         = field_get_items('node', $node_original, 'field_software_repo');
  $repo_value_original = $field_items[0]['value'];
  $field_items         = field_get_items('node', $node_updated, 'field_software_repo');
  $repo_value_updated  = $field_items[0]['value'];
  $same_repo           = ($repo_value_updated === $repo_value_original);

  $field_items = field_get_items('node', $node_original, 'field_rbuild_short_name');
  $short_name_value_original = $field_items[0]['value'];
  $field_items = field_get_items('node', $node_updated, 'field_rbuild_short_name');
  $short_name_value_updated = $field_items[0]['value'];
  $same_short_name = ($short_name_value_updated === $short_name_value_original);

  // Exits if the rBuild fields have not changed.
  if ($same_repo && $same_short_name) {
    return;
  }

  _os_software_delete_child_releases($node);
  _rbuild_node_save_modify_docs_field_value($node);
  _rbuild_init_releases($node);
}

/**
 * OpenScholar hooks
 */

/**
 * Implements hook_os_packaging_method_option().
 */
function rbuild_os_packaging_method_option() {
  $options = array(
    'Rbuild repository' => t('Rbuild repository'),
  );

  return $options;
}

/**
 * Implements hook_os_software_process_remote_release().
 */
function rbuild_os_software_process_remote_release() {

  // Checks for new releases every 20 minutes, invoked by cron.
  //20 * 60;
  $default_interval = 20;
  $interval         = variable_get('rbuild_cron_update_interval', $default_interval);
  $now              = time();

  $rbuild_project_nodes = _rbuild_query_all_rbuild_project_nodes();

  foreach ($rbuild_project_nodes as $project_node) {
    $time_to_check = (bool)(($project_node->changed + $interval) < $now);
    if ($time_to_check === TRUE) {
      // Imports any new file and creates Software Release node
      _rbuild_fetch_new_releases($project_node);
    }
  }
}

/**
 * Custom functions
 */

/**
 * Checks for and imports any new releases.
 *
 * @param object $project_node
 *   An individual project node with packaging method "Rbuild repository"
 *
 * @see rbuild_os_software_process_remote_release()
 */
function _rbuild_fetch_new_releases($project_node) {
  $handler = _rbuild_new_handler($project_node);
  if (!method_exists($handler, 'find_new_releases')) {
    return;
  }

  // Saves the project node if new releases are found
  $found_new_releases = $handler->find_new_release($project_node);
  if ($found_new_releases) {
    node_save($project_node);
  }
}

/**
 * Checks for and imports any new releases.
 *
 * @param object $project_node
 *   An individual project node with packaging method "Rbuild repository"
 *
 * @see rbuild_os_software_process_remote_release()
 */
function _rbuild_init_releases($project_node) {
  $handler = _rbuild_new_handler($project_node);
  if (!method_exists($handler, 'init_releases')) {
    return;
  }

  // Saves the project node if new releases are found
  $init_releases = $handler->init_releases($project_node);
  // if ($init_releases) {   node_save($project_node); }
}

/**
 * Creates a new Software Release node if the version is new.
 *
 * @param object $project_node
 *   The parent Software Project node, which will be referenced by a field.
 * @param string $version
 *   The text version info from the remote server for the new Release.
 * @param string $filename
 *   The package file to be saved to the release node field for download.
 * @param array $package
 * @param string $url
 * @param array $context
 */
function _rbuild_add_release_node_wrapper($project_node, $version, $filename, $package, $url, &$context = array()) {
  $node_exists = _rbuild_query_release_node_exists($project_node->nid, $version);
  if ($node_exists) {
    return FALSE;
  }

  _rbuild_add_release_node($project_node, $version, $filename, $package, $url, &$context);
  return TRUE;
}

/**
 * Creates a new Software Release node.
 *
 * @param object $project_node
 *   The parent Software Project node, which will be referenced by a field.
 * @param string $version
 *   The text version info from the remote server for the new Release.
 * @param string $filename
 *   The package file to be saved to the release node field for download.
 * @param array $package
 * @param string $url
 * @param array $context
 */
function _rbuild_add_release_node($project_node, $version, $filename, $package, $url, &$context = array()) {
  $start_time = time();
  $default_language = 'und';

  // Prepares basic settings of our new Software Release node
  $node           = new stdClass();
  $node->type     = 'software_release';
  $node->uid      = $project_node->uid;
  $node->language = $default_language;
  $node->status   = 1;
  $node->active   = 1;

  // Adds $node->nid and more properties
  node_save($node);
  $node = node_load($node->nid);
  if (module_exists('vsite')) {
    include_once (drupal_get_path('module', 'vsite') . '/includes/vsite.inc');
    vsite_add_entity($node);
  }

  // Prepares field values
  $recommended = ($version == $package['version']) ? 1 : 0;
  $file = _rbuild_import_file($url, $filename, $project_node->uid);
  if ($file === FALSE) {
    return;
  }

  // Sets field values using entity_metadata_wrapper
  $wrapper = entity_metadata_wrapper('node', $node);

  if ($file->timestamp < $start_time) {
    $wrapper->created->set($file->timestamp);
  }

  $wrapper->field_software_project->set($project_node->nid);
  $wrapper->field_software_version->set($version);
  $wrapper->field_software_recommended->set($recommended);
  $wrapper->field_software_package->set((array)$file);
  $wrapper->save();

  $context['results'][] = $node->nid . ' : ' . $node->title;
  $context['message'] = $node->title;
}

/**
 * Creates a new Drupal File object for a remote file.
 *
 * @param string $path
 *   The external path of the file to import.
 * @param string $filename
 *   The filename of the file located at the external path.
 * @param int $uid
 *   The Drupal user ID who owns the returned file
 * @param bool $get_contents
 *   Whether or not to retrieve the file contents.
 *
 * @return object $file
 *   A Drupal File object to attach to a new Software Release node.
 */
function _rbuild_import_file($url, $filename, $uid, $get_contents = FALSE) {

  $filepath = $url . '/' . $filename;

  // Only allows import of Gzip files
  $filemime = file_get_mimetype($filepath);
  if ($filemime !== 'application/octet-stream') {
    drupal_set_message(t('Expected file mimetype "application/octet-stream", not' . $file->filemime), 'error');
    return FALSE;
  }

  // Saves file to the root of the files directory.
  $contents      = file_get_contents($filepath);
  $file          = file_save_data($contents, 'public://' . $filename, FILE_EXISTS_RENAME);
  $file->display = 1;

  return $file;
}

/**
 * Gets the file contents of a remote file using curl.
 *
 * @param string $url
 *   The URL to fetch data from.
 *
 * @return mixed
 *   If the response is 404, returns FALSE
 *   Else, returns the output from curl_exec()
 */
function _rbuild_get_file_contents($url) {
  // Initializes curl session
  $ch = curl_init();

  // Set curl to return the data instead of printing it to the browser.
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_URL, $url);

  // Executes curl fetch
  $data = curl_exec($ch);

  $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
  curl_close($ch);

  // Exits if HTTP status not OK
  if ((int)$http_code !== (int)200) {
    return FALSE;
  }

  return $data;
}

/**
 * Returns file headers on a URL using curl.
 *
 * @param string $url
 *   The URL to fetch headers for.
 *
 * @return array $headers
 *   An array of strings containing header information.
 */
function _rbuild_get_file_headers($url) {
  $ch = curl_init();

  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_HEADER, TRUE);
  curl_setopt($ch, CURLOPT_NOBODY, TRUE);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($ch, CURLOPT_TIMEOUT, 10);

  $response = curl_exec($ch);
  $headers = explode('\n', $response);
  curl_close($ch);

  return $headers;
}

/**
 * Finds all Software Project nodes set to Rbuild.
 *
 * @return array $project_nodes
 *   An array of loaded Software Project node objects.
 */
function _rbuild_query_all_rbuild_project_nodes() {
  $query = new EntityFieldQuery();
  // Published
  $query->entityCondition('entity_type', 'node')->propertyCondition('type', 'software_project')->propertyCondition('status', 1)
  // run the query as user 1
  ->fieldCondition('field_software_method', 'value', 'Rbuild repository', '=')->fieldCondition('field_software_repo', 'value', '', '!=')
  ->addMetaData('account', user_load(1));

  $result = $query->execute();
  $project_nodes = _rbuild_query_load_nodes($result);
  return $project_nodes;
}

/**
 * Finds all Software Release nodes for a given Project and Version.
 *
 * @return bool $exists
 *   Only TRUE if query returns at least 1 result, otherwise FALSE.
 */
function _rbuild_query_release_node_exists($project_nid, $version) {
  $exists = FALSE;

  $query = new EntityFieldQuery();
  // Published
  $query->entityCondition('entity_type', 'node')->propertyCondition('type', 'software_release')->propertyCondition('status', 1)
  // run the query as user 1
  ->fieldCondition('field_software_project', 'target_id', $project_nid, '=')->fieldCondition('field_software_version', 'value', $version, '=')
  ->addMetaData('account', user_load(1));
  $result = $query->execute();

  if (isset($result['node'])) {

    $exists = TRUE;

  }

  return $exists;
}

/**
 * Returns an array of loaded nodes.
 *
 * @param object $query_result
 *   An EntityFieldQuery where entity_type = node
 *
 * @return mixed $result
 *   An array of node entity objects, or empty array if no results.
 *
 * @todo possibly rename and move elsewhere as a generic helper function.
 * @see _rbuild_query_all_rbuild_project_nodes()
 */
function _rbuild_query_load_nodes($result) {
  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    $nodes = entity_load('node', $nids);
    return $nodes;
  }

  return array();
}

/**
 *
 * Enter description here ...
 *
 * @param object $node
 *   A Software Project [software_project] type node.
 *
 * @return object $handler
 */
function _rbuild_new_handler($node) {
  // Requires the [:rbuild_handler:] PHP class
  require_once ('rbuild.handler.inc');

  // Prepares parameters to construct an Rbuild Handler object
  $field_items = field_get_items('node', $node, 'field_software_repo');
  $repo_url = $field_items[0]['value'];

  $field_items = field_get_items('node', $node, 'field_rbuild_short_name');
  $short_name = $field_items[0]['value'];

  // Instantiates a handler object to process cron
  $handler = new rbuild_handler($repo_url, $short_name);
  return $handler;
}

/**
 * Responds to batch import completion
 *
 * @see rbuild_handler::init_releases()
 */
function _rbuild_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(format_plural(count($results), '1 release processed.', '@count releases processed.'));
  }
  else {
    drupal_set_message(t('Unable to import all release information.'));
  }
}

/**
 * Checks that the provided Repository URL and Short Name are valid.
 *
 * @param array $form
 * @param array $form_state
 */
function _rbuild_project_node_validate($form, &$form_state) {
  $lang = $form_state['values']['language'];
  if ($form_state['values']['field_software_method'][$lang][0]['value'] !== 'Rbuild repository') {
    return;
  }

  $repo_url = $form_state['values']['field_software_repo'][$lang][0]['value'];
  $short_name = $form_state['values']['field_rbuild_short_name'][$lang][0]['value'];

  // Requires the [:rbuild_handler:] PHP class
  require_once ('rbuild.handler.inc');

  // Instantiates a handler object to validate
  $handler = new rbuild_handler($repo_url, $short_name);
  $handler->validate();
}

/**
 * Modifies the rbuild docs field value before node save.
 *
 * Only triggers for new nodes, and for changed rbuild repo or short name.
 *
 * @param object $node
 *   a project-type node
 *
 * @see hook_node_insert()
 * @see hook_node_update()
 */
function _rbuild_node_save_modify_docs_field_value(&$node) {
  $items = field_get_items('node', $node, 'field_rbuild_short_name');
  $short_name = $items[0]['value'];

  $docs_path = _rbuild_docs_source_path($short_name);
  $node->field_rbuild_docs[$node->language][0]['value'] = $docs_path;
}

/**
 * Formats a documentation URL
 *
 * @param string $short_name
 * @param string $version
 *
 * @return string $url
 *
 * @see _rbuild_node_save_modify_docs_field_value()
 */
function _rbuild_docs_source_path($short_name, $version = '') {
  $url_parts = array(
    'http://r.iq.harvard.edu/docs/',
    strtolower($short_name),
    /* Links to the parent directory now, not the index.shtml for latest version.
       *
       * Why? Because the index.shtml pages tend to link to deprecated OS /docs/ page.
       * However, r.iq.harvard.edu automatic index generation does not.
       * Furthermore, this way exposes documentation for all releases.
       '/',
      $version,
      '/index.shtml',
       */
  );

  $url = implode('', $url_parts);
  return $url;
}

